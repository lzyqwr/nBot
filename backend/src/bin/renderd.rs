use axum::{
    http::StatusCode,
    routing::{get, post},
    Json, Router,
};
use base64::Engine;
use serde::{Deserialize, Serialize};
use tokio::process::Command;
use tokio::time::{timeout, Duration};
use tracing::{error, info, warn};

#[derive(Serialize)]
struct HealthResponse {
    status: &'static str,
    service: &'static str,
}

#[derive(Deserialize)]
struct RenderRequest {
    html: String,
    #[serde(default)]
    width: Option<u32>,
    #[serde(default)]
    quality: Option<u8>,
    #[serde(default)]
    format: Option<String>,
}

#[derive(Serialize)]
struct RenderResponse {
    status: &'static str,
    #[serde(skip_serializing_if = "Option::is_none")]
    image: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    message: Option<String>,
}

async fn health() -> Json<HealthResponse> {
    Json(HealthResponse {
        status: "ok",
        service: "wkhtmltoimage",
    })
}

fn clamp_width(width: Option<u32>) -> u32 {
    match width {
        Some(w) => w.clamp(240, 1400),
        None => 420,
    }
}

fn clamp_quality(quality: Option<u8>) -> u8 {
    match quality {
        Some(q) => q.clamp(10, 100),
        None => 90,
    }
}

fn normalize_format(fmt: Option<String>) -> &'static str {
    match fmt.as_deref().map(|s| s.trim().to_ascii_lowercase()) {
        Some(s) if s == "jpg" || s == "jpeg" => "jpg",
        Some(s) if s == "png" => "png",
        _ => "png",
    }
}

async fn render(Json(req): Json<RenderRequest>) -> (StatusCode, Json<RenderResponse>) {
    if req.html.trim().is_empty() {
        return (
            StatusCode::BAD_REQUEST,
            Json(RenderResponse {
                status: "error",
                image: None,
                message: Some("缺少 html 参数".to_string()),
            }),
        );
    }

    // Basic abuse protection: keep render payload bounded.
    // Rendered HTML is generated by nBot, but this service may be exposed on localhost.
    const MAX_HTML_BYTES: usize = 2 * 1024 * 1024; // 2 MiB
    if req.html.len() > MAX_HTML_BYTES {
        return (
            StatusCode::PAYLOAD_TOO_LARGE,
            Json(RenderResponse {
                status: "error",
                image: None,
                message: Some("HTML 过大（>2MiB），拒绝渲染".to_string()),
            }),
        );
    }

    let width = clamp_width(req.width);
    let quality = clamp_quality(req.quality);
    let fmt = normalize_format(req.format);

    let temp_id = rand::random::<u64>();
    let temp_dir = std::env::temp_dir();
    let html_path = temp_dir.join(format!("nbot_render_{}.html", temp_id));
    let img_path = temp_dir.join(format!("nbot_render_{}.{}", temp_id, fmt));

    if let Err(e) = std::fs::write(&html_path, req.html.as_bytes()) {
        return (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(RenderResponse {
                status: "error",
                image: None,
                message: Some(format!(
                    "写入临时 HTML 失败: {} (路径: {})",
                    e,
                    html_path.display()
                )),
            }),
        );
    }

    let html_path_str = html_path.to_string_lossy().to_string();
    let img_path_str = img_path.to_string_lossy().to_string();

    info!(
        "render: wkhtmltoimage width={} quality={} fmt={} temp_id={}",
        width, quality, fmt, temp_id
    );

    let wkhtmltoimage_bin = std::env::var("WKHTMLTOIMAGE_BIN")
        .ok()
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .unwrap_or_else(|| "wkhtmltoimage".to_string());

    let mut cmd = Command::new(&wkhtmltoimage_bin);
    cmd.args([
        "--quality",
        &quality.to_string(),
        "--width",
        &width.to_string(),
        "--disable-javascript",
        "--encoding",
        "utf-8",
        "--load-error-handling",
        "ignore",
        "--load-media-error-handling",
        "ignore",
        &html_path_str,
        &img_path_str,
    ]);

    let output = match timeout(Duration::from_secs(120), cmd.output()).await {
        Ok(Ok(out)) => out,
        Ok(Err(e)) => {
            let _ = std::fs::remove_file(&html_path);
            if e.kind() == std::io::ErrorKind::NotFound {
                return (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(RenderResponse {
                        status: "error",
                        image: None,
                        message: Some(format!(
                            "wkhtmltoimage 不存在：请安装 wkhtmltopdf/wkhtmltoimage（或设置 WKHTMLTOIMAGE_BIN），当前: {}",
                            wkhtmltoimage_bin
                        )),
                    }),
                );
            }
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(RenderResponse {
                    status: "error",
                    image: None,
                    message: Some(format!("执行 wkhtmltoimage 失败: {}", e)),
                }),
            );
        }
        Err(_) => {
            let _ = std::fs::remove_file(&html_path);
            let _ = std::fs::remove_file(&img_path);
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(RenderResponse {
                    status: "error",
                    image: None,
                    message: Some("渲染超时（>120s）".to_string()),
                }),
            );
        }
    };

    let stderr = String::from_utf8_lossy(&output.stderr).to_string();
    let stdout = String::from_utf8_lossy(&output.stdout).to_string();

    if !output.status.success() {
        let _ = std::fs::remove_file(&html_path);
        let _ = std::fs::remove_file(&img_path);
        warn!("wkhtmltoimage failed: {}", stderr);
        return (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(RenderResponse {
                status: "error",
                image: None,
                message: Some(format!(
                    "渲染失败 (exit={}): {}{}",
                    output.status.code().unwrap_or(-1),
                    stderr,
                    if stdout.trim().is_empty() {
                        String::new()
                    } else {
                        format!("\n{}", stdout)
                    }
                )),
            }),
        );
    }

    let bytes = match std::fs::read(&img_path) {
        Ok(b) => b,
        Err(e) => {
            let _ = std::fs::remove_file(&html_path);
            let _ = std::fs::remove_file(&img_path);
            error!("read rendered image failed: {}", e);
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(RenderResponse {
                    status: "error",
                    image: None,
                    message: Some(format!("读取渲染结果失败: {}", e)),
                }),
            );
        }
    };

    let _ = std::fs::remove_file(&html_path);
    let _ = std::fs::remove_file(&img_path);

    let b64 = base64::engine::general_purpose::STANDARD.encode(&bytes);
    (
        StatusCode::OK,
        Json(RenderResponse {
            status: "success",
            image: Some(b64),
            message: None,
        }),
    )
}

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt::init();
    let port: u16 = std::env::var("PORT")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(8080);

    let app = Router::new()
        .route("/health", get(health))
        .route("/render", post(render));

    let addr = format!("0.0.0.0:{}", port);
    let listener = match tokio::net::TcpListener::bind(&addr).await {
        Ok(l) => l,
        Err(e) => {
            error!("bind {} failed: {}", addr, e);
            std::process::exit(1);
        }
    };
    info!("renderd listening on http://{}", addr);
    if let Err(e) = axum::serve(listener, app).await {
        error!("renderd exited: {}", e);
    }
}
